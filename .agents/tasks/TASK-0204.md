# TASK-0204: Flow A mode policy (customer vs owner) — mode-specific instructions/persona (hot-path safe)

Status: DONE  
Completed: 2026-02-18 (America/New_York)  
Owner: Codex Agent (Voice)  
Feature gate: `VOZ_FEATURE_VOICE_FLOW_A=1` (existing)  
Emergency rollback: `VOZ_FLOW_A_OPENAI_BRIDGE=0` (existing; disables OpenAI bridge)

## Goal
Use the **mode selected by access code** to apply mode-specific communication protocols in Flow A:

- `ai_mode=customer`: customer-facing assistant behavior
- `ai_mode=owner`: owner-facing assistant behavior (business-owner protocols / analytics tone)

**Contract note:** The Twilio Stream contract carries `ai_mode`.  
Flow A maintains back-compat by mapping `ai_mode` → internal `actor_mode` (`client|owner`) for an existing resolver.

## What shipped (final behavior)
1) Flow A reads `start.customParameters.ai_mode` and normalizes:
   - allowed: `{customer, owner}`
   - unknown/missing → defaults to `customer` (fail closed)

2) Mode affects voice/instructions selection using env-only policy (MVP):
   - Base defaults:
     - `VOZ_OPENAI_REALTIME_VOICE` (default voice)
     - `VOZ_OPENAI_REALTIME_INSTRUCTIONS` (base instructions; optional)
   - Enable tenant+mode policy:
     - `VOZ_FLOW_A_ACTOR_MODE_POLICY=1`
   - Provide per-tenant policy:
     - `VOZ_TENANT_MODE_POLICY_JSON='{"tenant_demo":{"owner":{"voice":"cedar","instructions":"..."},"client":{...}}}'`
   - Optional direct mode overrides:
     - `VOZ_OPENAI_REALTIME_VOICE_OWNER`, `VOZ_OPENAI_REALTIME_INSTRUCTIONS_OWNER`
     - `VOZ_OPENAI_REALTIME_VOICE_CLIENT`, `VOZ_OPENAI_REALTIME_INSTRUCTIONS_CLIENT`

3) Mode can also override instructions via:
   - `VOZ_FLOW_A_MODE_INSTRUCTIONS_JSON='{"customer":"...","owner":"..."}'`

## Acceptance tests
- Unit coverage exists in `tests/test_voice_flow_a.py` for:
  - ai_mode normalization and mapping
  - tenant policy fallback behavior
  - voice/instructions resolution ordering

## Invariants
- No DB calls or heavy prompt building on the Flow A hot path.
- Any additional mode-dependent behaviors must remain bounded and be kill-switched.

